{
dummyvar <- rep(0,nrow(data))
dummyvar[data[,attr] == category] <- sqrt(2) / 2
dummies <- cbind(dummies,dummyvar)
}
dummies <- as.data.frame(dummies)
dummylist[[attr]] <- dummylist[[attr]] + 1:ncol(dummies) - 1
if (length(dummylist) > attr)
{
for (entry in (attr+1):length(dummylist))
{
dummylist[[entry]] <- dummylist[[entry]] + ncol(dummies) - 1
}
}
names(dummies) <- paste(names(data)[attr],cats,sep=".")
dummycols <- dummycols + ncol(dummies) - 1
dummycols <- c(attr:(attr + ncol(dummies) - 1),dummycols)
data.new <- c()
data.names <- names(data)
if (attr > 1)
{
data.new <- cbind(data[,1:(attr-1)],dummies)
names(data.new) <- c(names(data)[1:(attr-1)],names(dummies))
# agl 5.9.2017: adjust attribute weights for nominal attributes by dividing them by the number of categories
# in order to assure equality between 2-cat nominal and 2-cat numeric attributes
#if (by.attr)
#{
#   if (length(cats) == 1)
#   {
#     attr.weight.new <- c(attr.weight[1:(attr-1)],attr.weight[attr])
#   } else attr.weight.new <- c(attr.weight[1:(attr-1)],rep(attr.weight[attr]/(length(cats)-1),length(cats)))
# } else
# {
attr.weight.new <- c(attr.weight[1:(attr-1)],rep(attr.weight[attr],length(cats)))
# }
} else
{
data.new <- dummies
names(data.new) <- names(dummies)
#if (by.attr)
#{
#   if (length(cats) == 1)
#   {
#     attr.weight.new <- c(attr.weight[attr])
#   } else attr.weight.new <- rep(attr.weight[attr]/(length(cats)-1),length(cats))
# } else
# {
attr.weight.new <- rep(attr.weight[attr],length(cats))
# }
}
# set weight of last dummy variable to zero in order to remove any impact of redundant information
#if (by.attr & (length(cats) > 1)) attr.weight.new[length(attr.weight.new)] <- 0
if (attr < ncol(data))
{
data.new.names <- names(data.new)
data.new <- cbind(data.new,data[,(attr+1):ncol(data)])
names(data.new) <- c(data.new.names,names(data)[(attr+1):ncol(data)])
attr.weight.new <- c(attr.weight.new,attr.weight[(attr+1):length(attr.weight)])
}
data <- data.new
attr.weight <- attr.weight.new
}
}
fl <- NA
fl.groups <- NA
fl.adjm <- NA
fl.num_sg <- NA
fl.mbr <- NA
fl.ind <- NA
fl.nofsg <- NA
distmat <- NA
# parallel processing
attr.weight.team <- attr.weight
dummycols.team <- dummycols
result <- mclapply(groups,faultlines.calc,group.vect=group.vect,data=data,method=method,maxgroups=maxgroups, metric=metric, attr.weight.team=attr.weight.team, attr.type = attr.type, dummycols.team=dummycols.team, dummylist=dummylist, quiet=TRUE,i.level=i.level,mc.cores=cores,usesghomo=usesghomo,by.attr=by.attr,mc.preschedule=TRUE)
#result <- unlist(result)
#res <- as.data.frame(do.call(rbind,result))
result$method=method
result$i.level=i.level
result$metric=metric
class(result) <- "aswclust"
return(result)
}
###########################################################################################################
###########################################################################################################
###########################################################################################################
# convert vector to text string
v2t <- function(x)
{
if (!is.na(x))
{
x.text <- ""
for (i in 1:length(x))
{
x.text <- paste(x.text,x[i],sep=" ")
}
} else
{
x.text <- "NA"
}
return(x.text)
}
print.aswclust <- function(x, ...)
{
pars <- 3
n.teams <- length(x) - pars
res <- (matrix(ncol=5,nrow=0))
for (i in 1:n.teams)
{
i.tab <- NA
i.freq <- NA
if (any(is.null(x[[i]]$mbr_to_subgroups))) x[[i]]$mbr_to_subgroups <- NA
if (any(!is.na(x[[i]]$mbr_to_subgroups)))
{
i.tab <- as.data.frame(table(x[[i]]$mbr_to_subgroups))
if (ncol(i.tab) == 2) i.freq <- i.tab[,2]
}
res <- rbind(res,c(x[[i]]$team,
x[[i]]$fl.value,
v2t(x[[i]]$mbr_to_subgroups),
v2t(x[[i]]$number_of_subgroups),
v2t(i.freq)))
}
res <- as.data.frame(res)
names(res) = c("team","fl.value","mbr_to_subgroups","number_of_subgroups","subgroup_sizes")
if (x$i.level == TRUE)
{
res$subgroup.association <- "multiple"
res$subgroup.sizes <- "multiple"
}
print(res)
}
summary.aswclust <- function(object, ...)
{
pars <- 3
n.teams <- length(object) - pars
method <- object$method
metric <- object$metric
level <- object$i.level
ifelse(object$i.level == TRUE, level <- "individual", level <- "team")
teams <- c()
flt <- c()
fli <- list()
nof_sg <- list()
nof_sg_text <- c()
mbr_sg <- list()
adjm <- list()
distmat <- list()
for (i in 1:n.teams)
{
teams <- c(teams,object[[i]]$team)
if (is.null(object[[i]]$fl.value)) object[[i]]$fl.value <- NA
flt <- c(flt,object[[i]]$fl.value)
nof_sg[[i]] <- object[[i]]$number_of_subgroups
nof_sg_text <- c(nof_sg_text,v2t(nof_sg[[i]]))
fli[[i]] <- object[[i]]$fl.ind
distmat[[i]] <- data.frame(object[[i]]$distmat)
if (object$i.level == TRUE)
{
mbr_sg[[i]] <- data.frame(object[[i]]$mbr_to_subgroups)
adjm[[i]] <- data.frame(object[[i]]$adjm)
} else
{
mbr_sg[[i]] <- object[[i]]$mbr_to_subgroups
adjm[[i]] <- NA
}
}
fltab <- data.frame(team = teams, fl.value = flt, number_of_subgroups = nof_sg_text)
res <- list(n.teams = n.teams,
method = method,
metric = metric,
level = level,
fltab = fltab,
fl.team = flt,
fl.ind = fli,
mbr_to_subgroups = mbr_sg,
number_of_subgroups = nof_sg,
adjm = adjm,
distmat = distmat,
long = convert.to.long(object))
class(res) = "summary.aswclust"
res
}
print.summary.aswclust <- function(x, ...)
{
cat("Number of Teams: ")
cat(x$n.teams,"\n\n")
cat("Calculation features: \n")
cat("\tMethod: \t",x$method,"\n")
cat("\tLevel: \t",x$level,"\n")
cat("\tMetric: \t", x$metric, "\n")
cat("\n")
for (team in 1:x$n.teams)
{
tstr <- paste("Team ",team," (",x$fltab[team,1],"):",sep="")
tul <- rep("=",nchar(tstr))
cat("\n",tstr,"\n",sep="")
cat(as.character(tul),"\n",sep="")
cat("Faultline Strength:\n")
print(x$fl.team[[team]])
cat("\n")
cat("Individual Faultline Strengths (silhouette widths):\n")
print(x$fl.ind[[team]])
cat("\n")
cat("Member to Subgroup Association:\n")
if (length(x$mbr_to_subgroups) > 0) print(x$mbr_to_subgroups[[team]]) else print(NA)
cat("\n")
cat("Number of Subgroups:\n")
if (length(x$number_of_subgroups) > 0) print(x$number_of_subgroups[[team]]) else print(NA)
cat("\n")
if (!is.na(x$adjm))
{
cat("Subgroup Network:\n")
print(x$adjm[[team]])
cat("\n")
}
cat("Distances:\n")
print(x$distmat[[team]])
cat("\n")
}
}
#################################
# function: get_weights
#################################
# Version:    1.0
# Date:       12.09.2017
# Author:     A. Glenz
#             a.glenz@psychologie.uzh.ch
#
# Purpose:
# Extract attribute weights for faultline calculation based on a given data set and a given group outcome vector
#################################
get_weights <- function(data,group.par="NA",attr.type=NA,n.rand=0,rescale=NA,method="asw",metric="euclid",maxgroups=6, i.level=FALSE, cores=1, usesghomo=FALSE,criterion,repetitions=1,quiet=FALSE)
{
library(parallel)
# analyze dataset
if (group.par=="NA" & !quiet)
stop("Dataset must contain data from multiple groups (we recommend at least 20).")
n.attr <- ncol(data)-1
if ((n.attr + n.rand) < 6 & !quiet)
{
warning(paste("We recommend at least 6 attributes (including random noise attributes). You specified only",n.attr,"data attributes and",n.rand,"random noise attributes."),immediate.=TRUE)
ans <- readline("Do you want to continue (y/n)? ")
if (ans != "y")
stop("Aborted by User")
}
n.groups <- length(unique(data[[group.par]]))
if (n.groups < 20 & !quiet)
{
warning(paste("We recommend that the data contains at least 20 groups. Your data has only",n.groups,"groups."),immediate.=TRUE)
ans <- readline("Do you want to continue (y/n)? ")
if (ans != "y")
stop("Aborted by User")
}
# generating random noise attributes
if (n.rand > 0)
{
for (rcol in 1:n.rand)
{
rndvar <- rnorm(nrow(data))
data <- cbind(data,rndvar)
}
names(data)[(length(names(data))-n.rand+1):length(names(data))] <- paste("rand",1:n.rand,sep="")
attr.type <- c(attr.type,rep("numeric",n.rand))
}
message(paste("Attribute names are:"))
attr.names <- names(data)[-which(names(data)==group.par)]
print(paste(attr.names,sep=", "))
if (!quiet)
{
ans <- readline("Is this correct (y/n)? ")
if (ans != "y")
stop("Aborted by User")
}
if (length(criterion) != n.groups  & !quiet)
stop(paste("The length of the criterion vector (",length(criterion),") does not match the number of groups (",n.groups,")",sep=""))
######### now do it...
require(R.utils)
n.spec <- n.attr + n.rand
combos <- intToBin(1:((2^n.spec)-1))
combos <- strsplit(combos,"")
starttime <- Sys.time()
numcalc <- length(combos) * repetitions
calc <- 0
res <- list()
for (turn in 1:repetitions)
{
fs.combos <- NA
fs.combos <- list()
for (i in 1:length(combos))
{
calc <- calc + 1
if (calc > 1)
{
curtime <- Sys.time()
print(paste("Calculating combination ",calc," of ",numcalc,". EOT at ",(curtime - starttime) / (calc-1) * (numcalc-calc-1) + curtime,sep=""))
} else
print(paste("Calculating combination ",calc," of ",numcalc,sep=""))
# re-generating random noise attributes
if (n.rand > 0)
{
data <- data[,1:(n.attr+1)]
for (rcol in 1:n.rand)
{
rndvar <- rnorm(nrow(data))
data <- cbind(data,rndvar)
}
names(data)[(length(names(data))-n.rand+1):length(names(data))] <- paste("rand",1:n.rand,sep="")
}
x <- faultlines(data, group.par=group.par,attr.type=attr.type,cores=cores,by.attr=TRUE,method=method,attr.weight=as.numeric(combos[[i]])[c(1:(n.attr+n.rand))],quiet=quiet,metric=metric,maxgroups=maxgroups, i.level=i.level, cores=1, usesghomo=usesghomo)
fs.combos[[i]] <- summary(x)$fltab$fl.value
}
#########
# calculate outcome correlations
fs.cor = fs.cor.p <- c()
for (i in 1:length(combos))
{
fs.cor[i] <- cor(fs.combos[[i]],criterion)
fs.cor.p[i] <- cor.test(fs.combos[[i]],criterion)$p.value
}
combos.df <- as.data.frame(matrix(as.numeric(unlist(combos)),ncol=n.spec,byrow=TRUE))
combos.sorted <- combos.df[order(fs.cor),]
names(combos.sorted) <- attr.names
numsig <- sum(fs.cor.p <= p.level)
############### calculate weights
chi.pos = chi.neg <- c()
chi.pos.p = chi.neg.p <- c()
w.pos = w.neg <- c()
occ.pos = occ.neg <- c()
exp.pos = exp.neg <- c()
for (a in 1:(n.attr + n.rand))
{
# h1: positive effects
roi <-
fs.cor[order(fs.cor)] > 0 &
1:nrow(combos.sorted) > as.integer(nrow(combos.sorted) * .5)
roi.size <- sum(roi)
roi.expected <- floor(roi.size / 2)
exp.pos[a] <- roi.expected
occ.pos[a] <- sum(combos.sorted[roi, a])
chi.pos[a] <- 0
if (occ.pos[a] > 0)
{
ct <-
chisq.test(c(roi.expected, sum(combos.sorted[roi, a])), p = c(.5, .5))
chi.pos[a] <-
round(ct$statistic * (2 * (sum(combos.sorted[roi, a]) >= roi.expected) - 1), 2)
}
chi.pos.p[a] <- 1
if (sum(combos.sorted[roi, a]) >= roi.expected)
chi.pos.p[a] <- ct$p.value
# h2: negative effects
roi <-
fs.cor[order(fs.cor)] < 0 &
1:nrow(combos.sorted) <= as.integer(nrow(combos.sorted) * .5)
roi.size <- sum(roi)
roi.expected <- floor(roi.size / 2)
exp.neg[a] <- roi.expected
occ.neg[a] <- sum(combos.sorted[roi, a])
chi.neg[a] <- 0
if (occ.neg[a] > 0)
{
ct <-
chisq.test(c(roi.expected, sum(combos.sorted[roi, a])), p = c(.5, .5))
chi.neg[a] <-
round(ct$statistic * (2 * (sum(combos.sorted[roi, a]) >= roi.expected) - 1), 2)
}
chi.neg.p[a] <- 1
if (sum(combos.sorted[roi, a]) >= roi.expected)
chi.neg.p[a] <- ct$p.value
}
# calculate relative attribte weights
w.pos <- chi.pos * 0
if (any(chi.pos > 0))
w.pos <- chi.pos / max(chi.pos)
w.neg <- chi.neg * 0
if (any(chi.neg > 0))
w.neg <- chi.neg / max(chi.neg)
chi.res <-
data.frame(
Attribute = names(combos.sorted)[1:(n.attr + n.rand)],
exp.pos = format(exp.pos, nsmall = 0),
occ.pos = format(occ.pos, nsmall = 0),
chi2.pos = format(chi.pos, nsmall = 2),
w.pos = w.pos,
exp.neg = format(exp.neg, nsmall = 0),
occ.neg = format(occ.neg, nsmall = 0),
chi2.neg = format(chi.neg, nsmall = 2),
w.neg = w.neg
)
colnames(chi.res) <-
c(
"Attribute",
"exp_pos",
"obs_pos",
"chi2_pos",
"weight_pos",
"exp_neg",
"obs_neg",
"chi2_neg",
"weight_neg"
)
res[[turn]] <- chi.res
}
if (repetitions > 1)
{
for (i in 1:length(res))
{
for (col in 2:ncol(res[[i]]))
{
res[[i]][,col] <- as.numeric(as.character(res[[i]][,col]))
}
}
sum.res <- res[[1]] * 0
for (i in 1:length(res))
{
sum.res <- sum.res + res[[i]]
}
# perform chi-statistics on cumulated observations
chi.pos = chi.neg <- c()
chi.pos.p = chi.neg.p <- c()
w.pos = w.neg <- c()
occ.pos = occ.neg <- c()
exp.pos = exp.neg <- c()
for (a in 1:(n.attr + n.rand))
{
# h1: positive effects
exp.pos[a] <- sum.res[a,2]
occ.pos[a] <- sum.res[a,3]
chi.pos[a] <- 0
if (occ.neg[a] > 0)
{
ct <- chisq.test(c(exp.pos[a], occ.pos[a]), p = c(.5, .5))
chi.pos[a] <-
round(ct$statistic * (occ.pos[a] >= exp.pos[a]), 2)
}
chi.pos.p[a] <- 1
if (occ.pos[a] >= exp.pos[a])
chi.pos.p[a] <- ct$p.value
# h2: negative effects
exp.neg[a] <- sum.res[a,6]
occ.neg[a] <- sum.res[a,7]
chi.neg[a] <- 0
if (occ.neg[a] > 0)
{
ct <- chisq.test(c(exp.neg[a], occ.neg[a]), p = c(.5, .5))
chi.neg[a] <-
round(ct$statistic * (occ.neg[a] >= exp.neg[a]), 2)
}
chi.neg.p[a] <- 1
if (occ.neg[a] >= exp.neg[a])
chi.neg.p[a] <- ct$p.value
}
# calculate relative attribte weights
w.pos <- chi.pos * 0
if (any(chi.pos > 0))
w.pos <- chi.pos / max(chi.pos)
w.neg <- chi.neg * 0
if (any(chi.neg > 0))
w.neg <- chi.neg / max(chi.neg)
chi.res <-
data.frame(
Attribute = names(combos.sorted)[1:(n.attr + n.rand)],
exp.pos = format(exp.pos, nsmall = 0),
occ.pos = format(occ.pos, nsmall = 0),
chi2.pos = format(chi.pos, nsmall = 2),
w.pos = w.pos,
exp.neg = format(exp.neg, nsmall = 0),
occ.neg = format(occ.neg, nsmall = 0),
chi2.neg = format(chi.neg, nsmall = 2),
w.neg = w.neg
)
colnames(chi.res) <-
c(
"Attribute",
"exp_pos",
"obs_pos",
"chi2_pos",
"weight_pos",
"exp_neg",
"obs_neg",
"chi2_neg",
"weight_neg"
)
}
chi.res$weight_pos[chi.res$weight_pos < 0] <- 0
chi.res$weight_neg[chi.res$weight_neg < 0] <- 0
# normalize weights
if (n.rand > 0)
{
w.pos <- chi.res$weight_pos
w.pos[(length(w.pos) - n.rand + 1):length(w.pos)] <- 0
if (any(w.pos > 0)) w.pos <- w.pos / max(w.pos)
chi.res$weight_pos <- w.pos
w.neg <- chi.res$weight_neg
w.neg[(length(w.neg) - n.rand + 1):length(w.neg)] <- 0
if (any(w.neg > 0)) w.neg <- w.neg / max(w.neg)
chi.res$weight_neg <- w.neg
}
return(chi.res)
}
mycategorialdata <- data.frame(teamid = c(rep(1,6),rep(2,6)),
age = c("40 to 50","18 to 25","40 to 49","30 to 39","30 to 39",
"50 to 59","18 to 25", "18 to 25","30 to 39",
"40 to 49", "50 to 59","50 to 59"),
gender = c("f","m","f","f","m","f","f","f","m","m","m","m"),
ethnicity = c("A","B","A","D","C","B","A","A","B","B","C","C"))
my_cat_attr <- c("nominal", "nominal", "nominal")
my_FLS <- faultlines(data = mycategorialdata,
group.par = "teamid",
attr.type = my_cat_attr,
method = "shaw")
